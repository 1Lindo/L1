/*
Реализовать постоянную запись данных в канал (главный поток).
Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout.
Необходима возможность выбора количества воркеров при старте.

Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.
*/

/*
Создаю канал data для передачи данных между главным потоком и горутинами-воркерами и канал done для
оповещения воркеров о необходимости завершения работы.

Задаю число numWorkers горутин-воркеров, каждая из которых читает данные из канала data и выводит их в stdout.
Запускаю горутину, которая записывает произвольные данные в канал data.

Использую пакет os/signal для обработки сигналов завершения.
Оповещаю os/signal о необходимости обработки сигналов SIGINT и SIGTERM.
Запускаю горутину, которая закрывает канал done при получении любого из этих сигналов.

Для ожидания завершения воркеров использую WaitGroup.

Закрываю канал done, чтобы завершить работу всех воркеров => все горутины-воркеры выходят из цикла чтения
канала data. Это является безопасным способом завершения работы воркеров (закрытие канала приводит к получению
нулевого значения при чтении из канала).
*/

package main

import (
	"fmt"
	"os"
	"os/signal"
	"sync"
	"syscall"
)

func main() {
	const numWorkers = 5

	data := make(chan int)
	done := make(chan struct{})
	var wg sync.WaitGroup

	// Запускаем воркеры, которые записывают данные из канала в stdout
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for {
				select {
				case d := <-data:
					fmt.Println(d)
				case <-done:
					return
				}
			}
		}()
	}

	// Записываем данные в канал
	go func() {
		for i := 0; ; i++ {
			data <- i
		}
	}()

	// Обрабатываем сигналы завершения
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigs
		close(done)
	}()

	// Ждем завершения воркеров
	wg.Wait()
}
