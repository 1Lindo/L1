/*
Реализовать все возможные способы остановки выполнения горутины.
*/

package main

import (
	"context"
	"sync"
)

/*
1. Возврат из функции. Просто возвращаем значение из функции и горутина завершится.
*/
func myFunc1() {
	// ...
	return // Завершение горутины
}

/*
2. Отправляем в канал оповещение о завершении: это позволяет контролировать выполнение горутины из другой горутины.
Создаем канал, отправляем в него значение которое оповестит горутину о необходимости завершения, далее проверяем его значение в цикле.
*/
func myFunc2(done chan struct{}) {
	for {
		select {
		case <-done:
			// Завершение горутины
			return
		default:
			// Выполнение работы
		}
	}
}

/*
3. Использование контекста для отмены выполнения, который позволяет отменить выполнение горутины из другой горутины или
функции с помощью контекста.
Создаем контекст и передаем его в функцию горутины. Затем вызываем метод Done() контекста, чтобы остановить выполнение.
*/
func myFunc3(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			// Завершение горутины
			return
		default:
			// Выполнение работы
		}
	}
}

/*
4. Используем пакет sync для ожидания завершения. Создаем объект sync.WaitGroup, добавляем количество ожидаемых горутин,
вызываем метод Done() при завершении каждой горутины и вызываем метод Wait() для ожидания завершения всех горутин.
*/
func myFunc4(wg *sync.WaitGroup) {
	defer wg.Done()
	// Выполнение работы
}

func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	go myFunc4(&wg)
	// ...
	wg.Wait() // Ожидание завершения горутины
}
